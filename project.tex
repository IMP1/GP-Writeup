%--------
% Notes:
%   ~ADD       : Add the following.
%   ~REFERENCE : Reference the following paper/authors.
%   ~FIND      : Find a paper regarding the following.
%   ~CHECK     : Check that the following is met.
%   ~READ      : Read through the following paper/authors.
%   ~MENTION   : Mention the following.
%

\documentclass{UoYCSproject}
\author{Huw Taylor}
\title{Tracing and Debugging GP2}
\date{\today}
\supervisor{Dr. Detlef Plump}
\MEng
\wordcount
% ~16000 words (55 pages) total
\pagecount
\abstract{
% ~66 words
}
\acknowledgements{

}

\begin{document}

\maketitle
\tableofcontents
\listoffigures

\chapter{Introduction}
% ~1333 words
\section{Motivation}
The University of York has produced a graphical editor for creating graphs and graph programs. The editor depends on a compiler to produce the resultant graph, also made at the University of York. Both these tools are planned to be used by students in the coming academic year (2016/2017) for the GRAT module taught there.
The aim of this project is to show the intermediate steps of the programme, so that correctness of the compiler and the graphical editor can be ensured, and also so that students using these tools to learn how graph programmes work can see the process with a finer granularity.
\section{Ethics}
The project discussed has very few ethical considerations. It is not related to defence and there are no safety or security concerns.

\chapter{Literature Review}
% ~4000 words
% ~CHECK: Shows that you know what is happening in your field 
% ~CHECK: Justifies why your work is interesting or important 
% ~CHECK: establishes the theoretical framework/context for your work 
% ~CHECK: defends your choice of methodology 
% ~CHECK: avoids repeating previous researchersâ€™ mistakes
\section{Graph Programming}
\subsection{Graph Transformations}
A graph is a visual way of representing data and relationships. The formal definition is a set of vertices (nodes) \emph{V}, a set of edges \emph{E}, and a set of labels \emph{L}. Additionally \emph{source} and \emph{target} functions associate edges with nodes, and a \emph{label} function, which maps labels to edges and nodes.
The mathematical theory of Graph Transformation allows the transformation of graphs by way of rules.
Rules are formally defined in appendix X % ~ADD: formal definition of rules to apendix and link to them and add an informal defition too, maybe
This field was first proposed in the 1970s by Ehrig, Pfender \& Schneider and has since been added to by % ~ADD: references to double-pushout and single-pushout methods, as well as contributions to graph theory in general
\subsection{GP}
Graph Programming first was % ~FIND: first suggestion of GP
The University of York has developed a graph programming language \emph{GP}, and is developing a new implementation \emph{GP2}. The goal of both of these has been to write programs that manipulate graphs in terms of the graphs, rather than in general purpose languages like C or Java. The first GP was produced by Greg Manning. % ~REFERENCE: greg manning paper
A GP allows the application of \emph{programs} to graphs. A program is made up of rules and rudimentary control structures, such as conditions, and loops. The rules are executed non-deterministically on a graph, known as the \emph{Host Graph}. The resulting graph is known as the \emph{Derived Graph}.
Plump \& Steinart
% ~ADD: examples of simple graph programs illustrating calling rules (and the rules themselves), and loops, and
GP currently is separated into four components:
\begin{enumerate}
  \item The York Abstract Machine (YAM)
  \item The YAM Compiler
  \item The GXL to YAMG Converter
  \item The GP Editor
\end{enumerate}
% ~ADD: explanations for these four components
\subsubsection{YAM}
The YAM is written in C and focusses heavily on optimisation and performance, often sacrificing maintainability. It takes in the rules, represented in bytecode, and executes them on host graphs, on an abstract machine.
% ~REFERENCE: Alex elliot paper page 14
\subsubsection{YAM Compiler}
The YAM Compiler compiles an XML representation of the graph program and its rules into YAM bytecode to be run on the abstract machine. It is written in Haskell.
\subsubsection{GXL to YAMG Converter}
YAMG is YAM's internal graph structure, and the converter takes in GXL, which is a subset of XML and a standard format for representing graphs.
\subsubsection{GP Editor}
The GP Editor was a GUI written in Java which allowed the creation of graphs graphically, as well as defining rules. It also displayed the derived graph.
The GP Editor has had very little thought of usability put into it. There are very few instructions to those intenting to use the tool, and the editor itself does little to help new users.
% ~READ, ~MENTION: Zhang 2.3.2 (p31-32)
% ~READ, ~MENTION: Onder 3.2 (p15)

The main problem found with GP was that these components relied heavily upon each other, and documentation on how their interfaces are non-existent. % ~Spelling
This meant that all four components had to be regarded as a single system, which made alterations to any of them very difficult. This was the primary motivation behind GP2.

\subsection{GP2}

GP2 has a number of differences in the way in which it was implemented. As well as trying to address the issues of maintainability and usability, several features were added.
Instead of using an abstract machine, GP2 generates C code directly, which removes the reliance on YAM, the YAM compiler, and YAM graph and program formats. It means that any C compiler can be used to generate the bytecode. It also attempts to standardise and document the format of graphs and programs that it takes. This means that tools to generate graphs either graphically or programmatically can be created without reducing modularity or creating complexity and interdependance between the components of the system. % ~CHECK: This isn't bullshit
% ~MENTION: no longer non-deterministic. no backtracking and no longer the case that all solutions will be reached. Maybe mention the haskel one and its optional backtracking.
% ~READ, ~MENTION: Elliot 5.1 (p29-30)
% ~READ, ~MENTION: Bak 5.2 (p67)

\subsection{GP2 Editor}
The GP2 graphical editor for creating graphs and graph programs is currently under development. GP2 intends it to 
% ~READ, ~MENTION: Ivaylo's paper

\section{Tracing}
Tracing through the steps of a program has been around since % ~FIND: origins of tracing for debugging
It allows programmers to ensure that each step is procuding the right results.








% END OF LITERATURE REVIEW

\chapter{Approach}
\section{Requirement Identification}
% ~2000 words
\begin{enumerate}
	\item Rules must be able to be stepped through one at a time.
 	\item The current rule must be made apparent graphically somehow.
	\item \ldots
\end{enumerate}
\section{Design}
% ~3333 words
 * Lifecycle
 * Engineering approach
 * Time management and/or general plan
 
\subsection{Tools}
Not a lot really.
\begin{itemize}
  \item Git
  \item Some C compiler/IDE/something or another
  \item Dependencies for GP-Editor
  \item \ldots
\end{itemize}
\section{Implementation}

\chapter{Evaluation}
% ~3333 words
\chapter{Conclusions}
% ~1333 words
\section{Future Work}

% \bibliography{references}

\chapter{Appendices}
\end{document}